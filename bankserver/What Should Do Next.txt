[2020-04-19]
쓰레드를 고려하지 않은 코드를 session_pool.cpp에서 발견::
while (stop_ev_.wait_for(std::chrono::microseconds(100)) == std::future_status::timeout) {
	mtx.lock();
	size_t sl_sz = session_list.size();
	mtx.unlock();
	if (sl_sz > 0) {		
		thread client_thread([=]() {			
			mtx.lock();
			session* session_ptr_ = session_list.front();
			session_list.pop_front(); ----- *
			auto cli_ep = session_ptr_->cli_socket;
			mtx.unlock();
			tcp::socket client_handle = session_ptr_->accept_client(cli_ep);													
		});							
		client_thread.detach();
	}
}

위와 같은 코드가 있을 때 client_thread는 생성후 곧바로 detach되고 쓰레드가 만들어지는 조건이 sl_sz 즉, 세션 리스트에 세션이 하나라도 있다는 조건이다.

두 코드가 독립적으로 실행되므로 session_list.pop_front()코드가 동작하기 전에 sesion_list.size()를 조회한다면 팝 되기 전의 세션 리스트 사이즈가 조회 될 것이고

이후 생성되는 쓰레드에서는 pop_front()코드를 실행 할 때 이전과 같은 세션을 끌어오거나 최악의 경우, 비어있는 세션에서 pop_front코드를 실행해 서버가 멈추게 될 것이다.